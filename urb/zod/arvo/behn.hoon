!:  ::  %behn, agent execution
!?  163
::::
|=  pit=vase
=>  =~
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    rest of arvo
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  hood                                                ::  assembly plan
  $:  zus=@ud                                           ::  zuse kelvin
      sur=(list hoot)                                   ::  structures
      lib=(list hoof)                                   ::  libraries
      fan=(list horn)                                   ::  resources
      src=(list hoop)                                   ::  program
  ==                                                    ::
++  hoof  (pair term (unit (pair case ship)))           ::  resource reference
++  hoot  (pair bean hoof)                              ::  structure gate/core
++  hoop                                                ::  source in hood
  $%  [%& p=twig]                                       ::  direct twig
      [%| p=beam]                                       ::  resource location   
  ==                                                    ::
++  horn                                                ::  resource tree
  $%  [%ape p=twig]                                     ::  /~  twig by hand
      [%arg p=twig]                                     ::  /$  argument
      [%day p=horn]                                     ::  /|  list by @dr
      [%dub p=term q=horn]                              ::  /=  apply face
      [%fan p=(list horn)]                              ::  /.  list
      [%for p=path q=horn]                              ::  /,  descend
      [%hel p=@ud q=horn]                               ::  /%  propagate heel
      [%hub p=horn]                                     ::  /@  list by @ud
      [%man p=(map span horn)]                          ::  /*  hetero map
      [%nap p=horn]                                     ::  /_  homo map
      [%now p=horn]                                     ::  /&  list by @da
      [%saw p=twig q=horn]                              ::  /;  operate on
      [%see p=beam q=horn]                              ::  /:  relative to
      [%sic p=tile q=horn]                              ::  /^  cast
      [%toy p=mark]                                     ::  /mark/  static
  ==                                                    ::
++  silk                                                ::  construction layer
  $&  [p=silk q=silk]                                   ::  cons
  $%  [%bake p=mark q=beam r=path]                      ::  local synthesis
      [%boil p=mark q=beam r=path]                      ::  general synthesis
      [%call p=silk q=silk]                             ::  slam
      [%cast p=mark q=silk]                             ::  translate
      [%done p=(set beam) q=cage]                       ::  literal
      [%dude p=tank q=silk]                             ::  error wrap
      [%dune p=(set beam) q=(unit cage)]                ::  unit literal
      [%mute p=silk q=(list (pair wing silk))]          ::  mutant
      [%plan p=beam q=spur r=hood]                      ::  structured build
      [%reef ~]                                         ::  kernel reef
      [%ride p=twig q=silk]                             ::  silk thru twig
      [%vale p=mark q=ship r=*]                         ::  validate [our his]
  ==                                                    ::
++  volt  ?(%low %high)                                 ::  voltage
++  torc  $|(?(%iron %gold) [%lead p=ship])             ::  security control
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    local arvo
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  club                                                ::  agent action
  $%  [%kick ~]                                         ::  reboot
      [%kill ~]                                         ::  reboot and delete
      [%load p=?(%cold %warm) q=beak]                   ::  reload
      [%peer p=path]                                    ::  subscribe
      [%look p=path]                                    ::  peer then pull 
      [%poke p=ship q=cage]                             ::  apply
      [%pull p=path]                                    ::  unsubscribe
      [%stop ~]                                         ::  toggle suspend
      [%took ~]                                         ::  acknowledge rush
      [%wipe ~]                                         ::  reinitialize
  ==                                                    ::
++  dude  term                                          ::  local identity
++  gent  (pair ship dude)                              ::  global identity
++  stab  ?(%fail %live %over %stop)                    ::  status report
++  tare  (list tank)                                   ::  error abstraction
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    %behn cards
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  kiss-behn                                           ::  incoming request
  $:  [%behn p=dude q=club]                             ::  request to agent
      [%load p=dude q=?(%cold %warm) r=beak]            ::  load / reload
      [%stop p=dude]                                    ::  toggle pause
      [%unto p=dude q=club]                             ::  agent action
  ==                                                    ::
++  gift-behn                                           ::  outgoing result
  $%  [%coup p=(unit tare)]                             ::  %poke success
      [%lame p=tare]                                    ::  %poke failure
      [%meta p=vase]                                    ::  meta-gift
      [%stat p=stab q=(unit tare)]                      ::  installer status
      [%quit p=~]                                       ::  subscription stop
      [%reap p=(unit tare)]                             ::  peer result
      [%rush p=cage]                                    ::  subscription update
  ==                                                    ::
++  sign-behn                                           ::  incoming result
  $%  [%f gift-ford]                                    ::
      [%e gift-eyre]                                    ::
      [%d gift-dill]                                    ::
      [%c gift-clay]                                    ::
      [%a gift-ames]                                    ::
  ==                                                    ::
++  note-behn                                           ::  outgoing request
  !!                                                    ::
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    %behn state
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  axle                                                ::  all state
  $:  %0                                                ::  state version
      ore=(unit ship)                                   ::  who we are
      pol=(map ship mast)                               ::  apps by ship
  ==                                                    ::
++  gest                                                ::  subscriber data
  $:  sup=(map bone (pair ship path))                   ::  subscribers
      pus=(jug path bone)                               ::  srebircsbus
      qel=(map bone ,@ud)                               ::  implicit rush queue
  ==                                                    ::
++  mast                                                ::  ship state
  $:  sys=duct                                          ::  system duct
      sap=(map ship scad)                               ::  foreign contacts
      bum=(map dude seat)                               ::  running agents
      wub=(map dude sofa)                               ::  waiting queue
  ==                                                    ::
++  ffuc                                                ::  new cuff
    $:  p=(unit (set monk))                             ::  can be read by
        q=monk                                          ::  caused or created by
    ==                                                  ::
++  prey  (pair volt ffuc)                              ::  privilege
++  scad                                                ::  opaque for foreign
  $:  p=@ud                                             ::  index
      q=(map duct ,@ud)                                 ::  by duct
      r=(map ,@ud duct)                                 ::  by index
  ==                                                    ::
++  scar                                                ::  opaque input
  $:  p=@ud                                             ::  bone sequence
      q=(map duct bone)                                 ::  by duct
      r=(map bone duct)                                 ::  by bone
  ==                                                    ::
++  scup                                                ::  autoupdate
  $:  law=?(%cold %warm)                                ::  frozen/evergreen
      for=(trel ship desk case)                         ::  currently loaded
      ped=(set (pair ship desk))                        ::  dependency
  ==                                                    ::
++  seat                                                ::  agent state
  $:  mom=(unit duct)                                   ::  control duct 
      liv=?                                             ::  unstopped
      toc=torc                                          ::  privilege
      tyc=stic                                          ::  statistics
      ged=gest                                          ::  subscribers
      hav=vase                                          ::  running state
      pup=scup                                          ::  update control
      zam=scar                                          ::  opaque ducts
  ==                                                    ::
++  sofa  (qeu (pair duct kiss))                        ::  waiting kisses
++  stic                                                ::  statistics
  $:  act=@ud                                           ::  change number
      eny=@uvI                                          ::  entropy
      lat=@da                                           ::  time
  ==                                                    ::
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    vane header
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
=|  all=axle                                            ::  all vane state
|=  $:  $:  now=@da                                     ::  urban time
            eny=@uvI                                    ::  entropy
        ::  our=@p                                      ::  identity
        ==                                              ::
        ska=sled                                        ::  activate
    ==                                                  ::  opaque core
=>  =~                                                  ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    state machine
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  mo
  |_  $:  $:  our=@p 
              hen=duct
              moz=(list move)
          ==
          mast
      ==
  ++  mo-abed                                           ::  initialize
    |=  hen=duct
    ^+  +>
    =:  our   (need ore.all)
        ^hen  hen
      ==
    =+  mib=(~(get by pol) our)
    ?^  mib 
      +>.$(+<+ u.mib)
    +>.$(+<+ [hen ~ ~ ~])
  ::
  ++  mo-abet                                           ::  resolve
    ^-  [(list move) _+>+]
    [(flop moz) +>+]
  ::
  ++  mo-club                                           ::  act
    |=  [dap=dude pry=prey cub=club]
    !!
  ::
  ++  ap
    |_  $:  $:  dap=dude
                pry=prey
                sec=(unit cuff)
                ost=bone
            ==
            seat
        ==
    ++  ap-abed                                         ::  initialize
      |=  [dap=dude vot=volt]
      ^+  +>
      =:  ^dap  dap
          ^vot  ?:(=(%gold toc) %low vot)
        ==
      =+  unt=(~(get by q.zam) hen)
      ?^  unt
        +>.$(ost p.u.unt, sec q.u.unt)
      %=  +>.$
        ost  p.zam
        p.zam  +(p.zam)
        q.zam  (~(put by q.zam) hen p.zam)
        r.zam  (~(put by r.zam) p.zam hen)
      ==
    ::
    ++  ap-abet                                         ::  resolve
      ^+  +>
      +>(bum (~(put by dap) num +<+))
    ::
    ++  ap-club                                         ::  apply effect
      |=  cub=club
      ?-  -.cub
        %kill   !!
        %poke   (ap-poke +.cub)
        %peer   (ap-peer +.cub)
      ==
    ::
    ++  ap-find                                         ::  check for arm
      |=  cog=@tas
      ^-  ?
      (slab cog p.hav)
    ::
    ++  ap-give                                         ::  return result
      |=  git=gift
      ^+  +>
      +>(moz :_(moz [%give (~(got by r.zam) ost) git]))
    ::
    ++  ap-pass                                         ::  request action
      |=  [pax=path noh=note]
      ^+  +>
      +>(moz :_(moz [%pass pax (~(got by r.zam) ost)]))
    ::
    ++  ap-call                                         ::  call into vase
      |=  [cog=term vax=vase]
      ^-  [(unit tare) _+>]
      =+  puz=(mule |.((~(mint ut p.vax) [%noun [%cnzy cog]])))
      =-  ?-  -.zep
            %|  [`+.zep +>.$]
            %&  (ap-sake +.zep)
          ==
      ^=  zep 
      ?-    -.puz
          %|  [%| +.puz]
          %&
        =+  ton=(mock [q.vax q.p.puz] |=(* ~))
        ?-  -.ton
          %0  [%& p.ton]
          %1  [%| (turn p.ton |=(a=* (smyt (path a))))]
          %2  [%| p.ton]
        ==
      ==
    ++  ap-rush                                         ::  return rush
      |=  [pax=path cag=cage]
      !! 
    ++  ap-suck                                         ::  standard tare
      |=  msg=tape
      ^-  tare
      [%leaf (weld "behn: {<dap>}:" msg)]~
    ::
    ++  ap-soot                                         ::  note to vane
      |=  vax=vase
      ^-  (each ,@tas tare)
      ?.  &(?=([@ *] q.vax) ((sane %tas) -.q.vax))
        [%| (ap-suck "same: malformed note"]
      ?+  -.q.vax 
               [%| (ap-suck "same: unknown note {(trip -.q.vax)})]
        %exec  [%& %f]    ::  XX etc
      == 
    ::
    ++  ap-safe                                         ::  process move list
      |=  vax=vase
      ^-  (each (list move) tare)
      ?~  q.vax  [%& ~]
      =+  sud=(ap-same (slot 2 vax))
      ?:  ?=(%| -.sud)  sud
      =+  res=$(vax (slot 3 vax))
      ?:  ?=(%| -.res)  res
      [%& p.sud p.res]
    ::
    ++  ap-same                                         ::  process each move
      |=  vax=vase
      ^-  (each move tare)
      ?@  q.vax    [%| (ap-suck "same: invalid move (atom)")]
      ?^  -.q.vax  [%| (ap-suck "same: invalid move (bone)")]
      ?@  +.q.vax  [%| (ap-suck "same: invalid move (card)")]
      =+  cav=(slot 7 q.vax)
      =+  sto=-.q.vax
      ?:  =(0 sto)
        ?.  =(%pass +<.q.vax)
          [%| (ap-suck "same: invalid gift (bone 0)")]
        (ap-same-pass `duct`~ cav)
      =+  hun=(~(get by r.zam) sto)
      ?~  hun  [%| (ap-suck "same: invalid card (bone)")]
      ?+  +<.q.vax
        %rush  (ap-same-rush u.hun cav)
        %pass  (ap-same-pass u.hun cav)
        %quit  (ap-same-quit u.hun cav)
      ==
    ::
    ++  ap-same-quit                                    ::  quit move
      |=  [neh=duct vax=vase]
      ^-  (each move tare)
      ?^  q.vax  [%| (ap-suck "same: improper quit")]
      [%& neh %give %quit ~] 
    ::
    ++  ap-same-rush                                    ::  rush move
      |=  [neh=duct vax=vase]
      ^-  (each move tare)
      ?.  &(?=(^ q.vax) ?=(@ -.q.vax) ((sane %tas) -.q.vax))
        [%| (ap-suck "same: improper rush")]
      :^  %&  neh  %give
      :-  %meta
      :-  [%cell [%cube %rush %atom %tas] p.vax]
      [%rush q.vax]
    ::
    ++  ap-same-pass
      |=  [neh=duct vax=vase]
      ^-  (each move tare)
      =+  toh=(ap-soot vax)
      ?:  ?=(%| -.toh)  toh
      [%& neh %pass 
    ::
    ++  ap-save                                         ::  verify core
      |=  vax=vase
      ^-  (each vase tare)
      [%& vax]
    ::
    ++  ap-sake                                         ::  handle result
      |=  vax=vase
      ^-  [(unit tare) _+>]
      ?:  ?=(@ q.vax)
        [`(ap-suck "sake: invalid product (atom)") +>.$]
      =+  muz=(ap-safe (slot 2 vax))
      ?:  ?=(%| -.muz)  [`p.muz +>]
      =+  sav=(ap-save (slot 3 vax))
      ?:  ?=(%| -.sav)  [`p.sav +>]
      :-  ~
      %_  +>.$
        moz  (weld (flop p.muz) moz)
        hav  p.sav 
      ==
    ::
    ++  ap-poke                                         ::  apply message
      |=  cag=cage
      ^+  +>
      =+  spy=(cat 3 'poke-' p.cag)
      =+  [reh sto]=[!>(`@p`her) !>(`@ud`ost)]
      =+  ^=  [cog vax]
          ?:  (ap-find spy)
            [spy :(slop reh sto q.cag)]
          [%poke :(slop reh sto !>(`@tas`p.cag) 
            (ap-call spy :(slop !>(`@p`her) !>(`@p`ost) q.cag))
          (ap-call spy :(slop 
    ::
    ++  ap-peer
      |=  [her=ship 
    --
  --
--
        our  (need ore.all)

    ==
    =.  our  (need 
  ++  mo-abet
  --





  |_  our=@p
     
    |%                                                  ::  vane interface
    ++  call                                            ::  handle request
      |=  [hen=duct hic=(hypo (hobo kiss))]
      =>  .(q.hic ?.(?=(%soft -.q.hic) q.hic ((hard kiss) p.q.hic)))

      ?-    -.q.hic
          %init
        [p=~ q=..^$(pol.all (~(put by pol.all) p.q.hic hen ~ ~))]
      ::
          %rote
        (gawk hen p.q.hic q.q.hic ((hard ,[@ud rook]) r.q.hic))
      ::
          %roth
        (gawd hen p.q.hic q.q.hic ((hard ,[@ud roon]) r.q.hic))
      ::
          %wipe
        =+  mat=(~(got by pol.all) p.p.q.hic)
        ~?  !(~(has by bum.mat) q.p.q.hic)  [%wipe-lost q.p.q.hic]
        =.  bum.mat  (~(del by bum.mat) q.p.q.hic)
        =.  pol.all  (~(put by pol.all) p.p.q.hic mat)
        [p=~ q=..^$]
      ::
          ?(%mess %show %nuke %took %sire)
        |-  ^-  [p=(list move) q=_..^^$]
        =+  =|  law=(unit cuff)
            |-  ^-  $:  law=(unit cuff)
                        hap=hapt
                        kon=knob
                    ==
            :-  law
            ?-  -.q.hic
              ::  %cuff  $(q.hic q.q.hic, law (limp p.q.hic law))
              %mess  [p %mess q r]:q.hic
              %show  [p %show q r]:q.hic
              %nuke  [p %nuke q]:q.hic
              %took  [p %took q]:q.hic
              %sire  [[p.q +.q.q] %sire p -.q.q]:q.hic
            ==
        ((goad hen law) p.hap q.hap kon)
      ==
    ::
    ++  take                                            ::  accept response
      |=  [pax=path hen=duct hin=(hypo sign)]           ::
      ^-  [p=(list move) q=_..^$]
      ?:  ?=(%crud +<.q.hin)
        ~&  [%gall-crud-error pax hen]
        ~&  [%gall-crud-data (,[@tas (list tank)] +>.q.hin)]
        ?>  ?=(%g -.q.hin)
        ?~  pax  ~&  %strange-path  [~ ..^$]
        =+  lum=(lump t.pax)
        =+  mat=(~(get by pol.all) p.p.lum)
        ?~  mat  ~&  %no-ship  [~ ..^$]
        =+  sat=(~(get by bum.u.mat) q.p.lum)
        ?~  sat  ~&  %no-app  [~ ..^$]
        :-  `(list move)`[hen %give %crud p.q.hin q.q.hin]~
        %=    ..^$                                      ::  XX maybe call work?
            pol.all
          %+  ~(put by pol.all)  p.p.lum
          %=    u.mat
              bum
            %+  ~(put by bum.u.mat)  q.p.lum
            u.sat(qic ~)
          ==
        ==
      ?:  ?=([%r *] pax)
        (gave hen t.pax q.hin)
      ?:  ?=([%x *] pax)
        (gasp hen t.pax q.hin)
      ?>  ?=([%a *] pax)
      =+  lum=(lump t.pax)
      =+  mat=(~(get by pol.all) p.p.lum)
      ?~  mat  [~ ..^$]
      =+  sat=(~(get by bum.u.mat) q.p.lum)
      ?~  sat  [~ ..^$]
      ::  ?.  (~(has by q.zam.u.sat) hen)
      ::  ~&  [%app-lost pax hen p.lum q.lum]
      ::  [~ ..^$]
      =<  abet  =<  work
      (more:(bear:(gaff p.lum) hen) q.lum hin)
    ::
    ++  scry
      |=  $:  use=(unit (set monk))
              ren=@tas
              who=ship
              syd=desk
              lot=coin
              tyl=path
          ==
      ^-  (unit (unit (pair mark ,*)))
      =+  ^=  vew  ^-  lens                             ::  XX future scry
        %.  :-  use
            :-  [who syd ((hard case) p.lot)]
            (flop tyl)
        |=  $:  use=(unit (set monk))                   ::  observers
                bid=beam                                ::  position
            ==                                          ::
        (beef:(gaff p.bid q.bid ~) use r.bid s.bid)
      %+  bind
        ?+    ren  ~
          %u  u.vew
          %v  v.vew
          %w  w.vew
          %x  x.vew
          %y  y.vew
          %z  z.vew
        ==
      |=(a=(unit) (bind a |=(b=* [%noun b])))
    ::
    ++  doze
      |=  [now=@da hen=duct]
      ^-  (unit ,@da)
      ~&  %nighty-night
      [~ (add now ~s4)]
    ::
    ++  load
      |=  old=axle
      ^+  ..^$
      ..^$(all old)
    ::
    ++  stay  `axle`+>-.$
    --
|%                                                      ::  inner core
::
++  best                                                ::  cage to gift
  |=  [sem=?(%rush %rust) cay=cage]
  ^-  gift
  :-  %meta
  ^-  vase
  :-  :+  %cell  [%cube sem %atom %tas]
      [%cell [%cube p.cay %atom %tas] p.q.cay]
  [sem p.cay q.q.cay]
::
++  gaff                                                ::  take and go
  |=  [our=@p imp=path]
  =+  mat=(~(got by pol.all) our)
  =+  sat=(~(got by bum.mat) imp)
  ~(. go [our imp] mat sat)
::
++  gape                                                ::  %r send query
  |=  [hen=duct law=(unit cuff)]
  |=  [our=@p imp=path kon=knob]
  ^-  [(list move) _..^^$]
  ?>  ?=(?(%mess %show %nuke %took) -.kon)
  ?:  ?=(%took -.kon)
    ::  ~&  [%gape-took our imp hen]
    [~ ..^^$]
  =+  you=`ship`?-(-.kon %mess p.kon, %nuke p.kon, %show p.kon)
  =+  mut=(~(get by pol.all) you)
  ?~  mut
    ~&  [%gape-lost you hen]
    !!
  =+  mat=u.mut
  =+  sad==+(sad=(~(get by sap.mat) our) ?^(sad u.sad [.(p 1)]:*scad))
  =^  num  sad
      =+  nym=(~(get by q.sad) hen)
      ?^  nym  [u.nym sad]
      :-  p.sad
      :+  +(p.sad)
        (~(put by q.sad) hen p.sad)
      (~(put by r.sad) p.sad hen)
  :-  =+  ^=  roc  ^-  rook
          ?-  -.kon
            %mess  [%m p.q.kon q.q.q.kon]
            %nuke  [%u ~]
            %show  [%s q.kon]
          ==
      ^-  (list move)
      :~  :-  hen
          :+  %pass
            [%x -.roc (scot %p you) (scot %p our) (scot %ud num) imp]
          `note`[%a %wont [you our] [%q %ge imp] [num roc]]
      ==
  %=    ..^^$
      pol.all
    %+  ~(put by pol.all)
      you
    mat(sap (~(put by sap.mat) our sad))
  ==
::
++  gasp                                                ::  %x take
  |=  [hen=duct pax=path sih=sign]
  ^-  [(list move) _..^$]
  ?+    -.sih  !!
      %a
    ?.  ?=(%woot +<.sih)
      ~&  [%gall-bad-gasp-a pax=pax lgsih=+<.sih]
      ~&  [%gall-bad-gasp-b pax=pax sih=sih]  `..^$
    :_  ..^$  :_  ~
    ?~  q.sih
      [hen %give %nice ~]
    [hen %give %mean u.q.sih]
  ::
      %f
    :_  ..^$
    :_  ~
    :-  hen
    ?-    -.q.+.sih
        %|
      [%give %crud %gasp-crud p.q.+.sih]
    ::
        %&
      =+  cay=`cage`p.q.+.sih
      ?+  -.pax  !!
        %d  [%give (best %rush cay)]
        %f  [%give (best %rust cay)]
  ==  ==
    ==
::
++  gave                                                ::  %r take
  |=  [hen=duct pax=path sih=sign]
  ^-  [(list move) _..^$]
  ?>  ?=([@ @ @ @ *] pax)
  =+  :*  our=`ship`(slav %p i.t.pax)
          you=`ship`(slav %p i.t.t.pax)
          num=(slav %ud i.t.t.t.pax)
          imp=`path`t.t.t.t.pax
      ==
  ::  ~&  [%gall-gave hen -.pax [our you num imp]]
  :_  ..^$
  =+  rod=|=(ron=roon `note`[%a %wont [our you] [%q %gh imp] num ron])
  ?+  -.pax  !!
    %z  ?+    -.sih  !!
            %a  :_  ~  :-  hen
                [%pass [%r pax] %g %took [our imp] you]
        ::
            %f
          :_  ~  :-  hen
          ?-  -.q.+.sih
            %|  [%give %mean ~ %ford-fail p.q.+.sih]
            %&  [%pass [%r pax] %g %mess [our imp] you `cage`p.q.+.sih]
          ==
        ::
            %g
          :_  ~  :-  hen
          ?-  -.+.sih
            %crud  !!
            %dumb  !!
            %gone  !!
            %init  !!
            %logo  !!
            %mean  [%pass [%r pax] (rod %e p.+.sih)]
            %nice  [%give %nice ~]
            %rush  [%pass [%r pax] (rod %d p.+.sih q.+.sih)]
            %rust  ::  ~&  [%gave-rust [our you num imp] hen]
                   [%pass [%r pax] (rod %f p.+.sih q.+.sih)]
            %sage  !!
            %verb  !!
            %veer  !!
            %vega  !!
          ==
        ==
    %u  !!
  ==
::
++  gawd                                                ::  %r handle response
  |=  [hen=duct saq=sack imp=path num=@ud ron=roon]
  ^-  [p=(list move) q=_..^$]
  ?:  =(0 num)  ~&  %shouldnt-get-zero  `..^$
  =+  mat=(~(got by pol.all) p.saq)
  =+  sad=(~(got by sap.mat) q.saq)
  =+  neh=(~(got by r.sad) num)
  :_  ..^$
  :-  [hen %give %nice ~]  :_  ~
  ^-  move  :-  neh
  ?-  -.ron
    %d  [%pass /x/d `note`[%f %exec p.saq ~ %vale p.ron q.saq q.ron]]
    %e  [%give %mean p.ron]
    %f  [%pass /x/f `note`[%f %exec p.saq ~ %vale p.ron q.saq q.ron]]
    %k  [%give %nice ~]
  ==
::
++  gawk                                                ::  %r call/request
  |=  [hen=duct saq=sack imp=path num=@ud rok=rook]
  ^-  [p=(list move) q=_..^$]
  :_  ..^$  :_   ~
  ^-  move  :-  hen
  :+  %pass
    :*  %r
        ::  ?-(-.rok %m %m, %s %s, %u %s)
        %z
        (scot %p p.saq)
        (scot %p q.saq)
        (scot %ud num)
        imp
    ==
  ^-  note
  ?-  -.rok
    %m  [%f %exec p.saq ~ %vale p.rok q.saq q.rok]
    %s  [%g %show [p.saq imp] q.saq p.rok]
    %u  [%g %nuke [p.saq imp] q.saq]
  ==
::
++  gent                                                ::  seat in mast
  |=  [our=@p imp=path mat=mast]
  =+  ^=  sat  ^-  seat
      =+  syt=(~(get by bum.mat) imp)
      ?^  syt  u.syt
      ?.  ?=([@ ~] imp)  ~&  [%app-not-found imp]  !!
      %*  .  *seat
          app  i.imp
          zam
        ^-  scar
        :+  1
          [[hun.mat 0 ~] ~ ~]
        [[0 hun.mat] ~ ~]
      ==
  =.  bum.mat  (~(put by bum.mat) imp sat)
  ~(. go [our imp] mat sat)
::
++  goad                                                ::  handle request
  |=  [hen=duct law=(unit cuff)]
  |=  [our=@p imp=path kon=knob]
  ^-  [(list move) _..^^$]
  =+  mut=(~(get by pol.all) our)
  ?^  mut
    ?:  &(?=([@ @ *] imp) !(~(has by bum.u.mut) imp))   ::  %took for dead imps
      [~ ..^^$]
    abet:work:(quem:(boar:(gent our imp u.mut) hen law) kon)
  ((gape hen law) our imp kon)
::
++  go                                                  ::  application core
  |_  $:  $:  our=@p                                    ::  application owner
              imp=path                                  ::  application name
          ==                                            ::
          mat=mast                                      ::  per owner
          sat=seat                                      ::  per application
      ==                                                ::
  ++  abet                                              ::  resolve
    %_    ..$
        all
      %_  all
        pol  %+  ~(put by pol.all)  our
             ?.  (~(has by bum.mat) imp)
                ::  ~&  [%abet-gone imp]
                mat
             ::  ~&  [%onzes imp=imp onz=onz.sat]
             mat(bum (~(put by bum.mat) imp sat))
      ==
    ==
  ::
  ++  able                                              ::  bone to duct
    |=  ost=bone  ^-  duct
    ::  ?:  =(0 ost)
    ::  hun.mat
    (~(got by r.zam.sat) ost)
  ::
  ++  away                                              ::  application path
    |=  pax=path  ^-  path
    [%a (scot %p our) ?~(imp %$ (pack imp)) pax]
  ::
  ++  bear                                              ::  write backward
    |=  hen=duct
    =+  orf=(fall (~(get by q.zam.sat) hen) [p=0 q=*(unit cuff)])
    ~(apex bo:~(. au (read q.orf)) hen p.orf (rite q.orf) ~)
  ::
  ++  beef                                              ::  read in
    |=  [use=(unit (set monk)) lok=case pax=path]
    ^-  lens
    ?.  =([%da now] lok)  *lens
    (~(show au use) pax)
  ::
  ++  boar                                              ::  write forward
    |=  $:  hen=duct                                    ::  cause
            law=(unit cuff)                             ::  permissions
        ==
    =^  orf  zam.sat
      =+  orf=(~(get by q.zam.sat) hen)
      ?^  orf
        [[p=p.u.orf q=(limp law q.u.orf)] zam.sat]
      :^  [p=p.zam.sat q=law]  +(p.zam.sat)
        (~(put by q.zam.sat) hen [p.zam.sat law])
      (~(put by r.zam.sat) p.zam.sat hen)
    ~(apex bo:~(. au (read q.orf)) hen p.orf (rite q.orf) ~)
  ::
  ++  au                                                ::  read
    |_  use=(unit (set monk))                           ::  read permission
    ++  abet  ^abet                                     ::  resolve
    ++  show                                            ::  view
      |=  pax=path
      ^-  lens
      ?~  huv.sat  *lens
      =+  gat=(slap u.huv.sat [%cnzy %peek])
      =+  cor=(slam gat !>([our pax]))
      =+  ^=  dek
          |*  fun=$+(vase *)
          |=  nam=@tas
          =+  vax=(slap cor [%cnzy nam])
          ^-  (unit (unit fun))
          ?:  =(~ q.vax)  ~
          ?:  =([~ ~] q.vax)  [~ ~]
          [~ ~ (fun (slot 7 vax))]
      =+  ^=  nib
          |=  vax=vase
          ((hard null) q.vax)
      =+  ^=  yob
          |=  vax=vase  ^-  cage
          [((hard mark) -.q.vax) (slot 3 vax)]
      =+  ^=  yar
          |=  vax=vase  ^-  arch
          ((hard arch) q.vax)
      =+  ^=  dif
          |=  vax=vase  ^-  (unit cage)
          ?:  =(~ q.vax)  ~
          [~ (yob (slot 3 vax))]
      |%
      ++  u  ((dek nib) %u)
      ++  v  ((dek yob) %v)
      ++  w  ((dek dif) %w)
      ++  x  ((dek yob) %x)
      ++  y  ((dek yar) %y)
      ++  z  ((dek yob) %z)
      --
    ::
    ++  bo
      |_  $:  hen=duct                                  ::  system cause
              ost=bone                                  ::  opaque cause
              say=(unit (set monk))                     ::  write permission
              mow=(list move)                           ::  actions
          ==
      ++  abet  [(flop mow) ^abet]                      ::  resolve
      ++  apex                                          ::  enter
        ^+  .
        ?.  &(=(~ huv.sat) =(~ qic.sat) =(~ vey.sat) =(~ ped.sat))  .
        %_(. vey.sat (~(put to vey.sat) hen [%boot ~]))
      ::
      ++  bing                                          ::  reset to duct
        |=  neh=duct
        =+  orf=(fall (~(get by q.zam.sat) neh) [p=0 q=*(unit cuff)])
        %_    +>.$
            hen  neh
            ost  p.orf
            use  (read q.orf)
            say  (rite q.orf)
        ==
      ::
      ++  birf
        |=  [wir=wire hon=duct caq=vase]
        ^-  move
        ?>  ?=([%pass p=* q=%g r=[p=%sire q=term r=span]] q.caq)
        [hon %pass wir %g %sire q.r.q.caq our r.r.q.caq imp]
      ::
      ++  blow
        ^+  .
        ::  ~&  [%gall-blow ost]
        =>  (give %mean ~)
        =+  pax=+:(fall (~(get by sup.sat) ost) *[ship path])
        %=  +
          qic.sat  ~
          sup.sat  (~(del by sup.sat) ost)
          pus.sat  (~(del ju pus.sat) pax ost)
          peq.sat  (~(del by peq.sat) ost)
        ==
      ::
      ++  cave                                          ::  vase as silk
        |=  vax=vase
        [%done ~ %$ vax]
      ::
      ++  conf                                          ::  configured core
        |=  kas=silk
        ^-  silk
        :+  %mute  kas
        :_  ~
        :-  [%$ 12]~
        (cave !>([[our app.sat imp] cub.sat sup.sat pus.sat [act.sat eny now]]))
      ::
      ++  core  |=(vax=vase (cove %core vax))           ::  core as silk
      ++  cove                                          ::  cage as silk
        |=  cay=cage
        ^-  silk
        [%done ~ cay]
      ::
      ++  deal                                          ::  reboot
        .(tik.sat +(tik.sat))
      ::
      ++  deff
        |=  [wir=wire hon=duct caq=vase]
        ^-  toil
        ?>  ?=([%pass p=* q=%g r=[p=%cide q=span]] q.caq)
        ::  ~&  [%deff imp cub.sat]
        [hon r.q.caq]
      ::
      ++  drug                                          ::  set dependencies
        |=  pen=(set (pair ship desk))
        :: ~&  [%drug ped=ped.sat]
        :: ~&  [%drug pen=pen]
        ^+  +>
        =+  ^=  new  ^-  (list move)
            %+  turn
              %+  skip  (~(tap in pen) ~)
              |=(a=(pair ship desk) (~(has in ped.sat) a))
            |=  a=(pair ship desk)
            :-  hun.mat
            :^  %pass  (away %w %drug (scot %p p.a) q.a ~)  %c
            ::  ~&  [%sync-subscribe our p.a q.a]
            [%warp [our p.a] q.a ~ %| [%da +(now)] [%da (add now ~d1000)] /]
        =+  ^=  old  ^-  (list move)
            %+  turn
              %+  skip  (~(tap in ped.sat) ~)
              |=(a=(pair ship desk) (~(has in pen) a))
            |=  a=(pair ship desk)
            :-  hun.mat
            :^  %pass  (away %w %drug (scot %p p.a) q.a ~)  %c
            ~&  [%sync-unsubscribe our p.a q.a]
            [%warp [our p.a] q.a ~]
        %_(+>.$ ped.sat pen, mow :(weld new old mow))
      ::
      ++  drum                                          ::  raw dependencies
        |=  dep=@uvH
        ^+  +>
        ?>  ?=(^ orm.sat)
        %-  drug
        =+  ped=`(set (pair ship desk))`[[our %main] ~ ~]
        ped
        ::=+  mav=(~(tap by dep) ~)
        ::|-  ^+  ped
        ::?~  mav  ped
        ::?:  =(r.i.mav [%da u.orm.sat])
        ::  $(mav t.mav, ped (~(put in ped) p.i.mav q.i.mav))
        ::$(mav t.mav)
      ::
      ++  ford                                          ::  exec to ford
        |=  [pax=path kas=silk]
        ^+  +>
        =.  kas
          :+  %dude
            leaf/"error in app {<app.sat>} on {<our>} at instance {<imp>}"
          kas
        %_    +>
            mow      :_(mow [hen %pass (away pax) %f [%exec our `kas]])
            onz.sat  `[hen pax]
        ==
      ::
      ++  give                                          ::  give a gift
        |=  gip=gift
        %_(+> mow [[hen %give gip] mow])
      ::
      ++  harm                                          ::  arm as silk
        |=  [arm=term kas=silk]
        ^-  silk
        [%ride [%cnzy arm] kas]
      ::
      ++  home                                          ::  load application
        ^-  silk
        [%boil %core [[our %main [%da now]] app.sat %app ~] ~]
      ::
      ++  leav
        %_  .
          bum.mat  (~(del by bum.mat) imp)
          qic.sat  ~
          mow 
            ?~  mom.sat  mow
            :_(mow [u.mom.sat %give %gone our imp])
          vey.sat
            %-  ~(gas by vey.sat)
            %+  turn  (~(tap by cub.sat))
            |=([a=span @] [hen %cide a])
        ==
      ::
      ++  mack                                          ::  apply standard
        |=  sih=sign
        ?>  ?=(%f -.sih)
        ^-  [(unit (list tank)) _+>]
        ?-  -.q.+.sih
          &  :-  ~
             %-  obey:(morn (slot 3 q.p.q.+.sih))
             (slot 2 q.p.q.+.sih)
          |  [`p.q.+.sih (give %crud %mack-made p.q.+.sih)]
        ==
      ::
      ++  meek                                          ::  apply peek
        |=  sih=sign
        ^-  [(unit cage) _+>]
        ?>  ?=(%f -.sih)
        ?-  -.q.+.sih
          &  =+  vax=`vase`q.p.q.+.sih
             ?.  &(?=(^ q.vax) ?=(@ -.q.vax))
               [~ (give %crud %peek-lame *(list tank))]
             ::  ~>  %slog.[0 (skol p:(slot 3 vax))]
             :-  `[((hard mark) -.q.vax) (slot 3 vax)]
             +>.$
          |  [~ (give %crud %meek-made p.q.+.sih)]
        ==
      ::
      ++  mick                                          ::  apply w/depends
        |=  sih=sign
        ?>  ?=(%f -.sih)
        ^-  [[p=? q=@uvH] _+>]
        :-  [-.q.+.sih p.+.sih]
        ?-  -.q.+.sih
          &  %-  obey:(morn (slot 3 q.p.q.+.sih))
             (slot 2 q.p.q.+.sih)
          |  (give %crud %mick-made p.q.+.sih)
        ==
      ::
      ++  muck                                          ::  apply part
        |=  sih=sign
        ^-  [(unit (list tank)) _+>]
        ?>  ?=(%f -.sih)
        ?-  -.q.+.sih
          &  [~ (obey q.p.q.+.sih)]
          |  [`p.q.+.sih (give %crud %muck-made p.q.+.sih)]
        ==
      ::
      ++  murk                                          ::  apply park
        |=  sih=sign
        ^-  [(unit cage) _+>]
        ?>  ?=(%f -.sih)
        ?-  -.q.+.sih
          &  [`p.q.+.sih +>.$]
          |  [~ (give %crud %murk-made p.q.+.sih)]
        ==
      ::
      ++  more                                          ::  domestic take
        |=  $:  pax=path                                ::  internal position
                hin=(hypo sign)                         ::  typed event
            ==
        ^+  +>
        ?+  -.pax  !!
            %s                                          ::  core operation
          ?.  ?&  ?=([@ *] t.pax)
                  !=(~ qic.sat)
                  =(`[hen pax] onz.sat)
              ==
            ~&  :*  %gall-mystery
                    imp  pax
                    ?~(qic.sat ~ [p -.q]:u.qic.sat)
                    onz.sat
                ==
            +>.$
          =:  onz.sat  ~
              qic.sat  ~
            ==
          ?+    i.t.pax  !!
          ::
              %park
            =^  gyd  +>.$  (murk q.hin)
            ?~  gyd
              +>.$
            (quen %load u.gyd)
          ::
              %part
            =^  gud  +>.$  (muck q.hin)
            ?^  gud  +>.$
            leav
          ::
              %peek
            ?>  ?=([@ *] t.t.pax)
            =+  you=(need (slaw %p i.t.t.pax))
            =^  gyd  +>.$  (meek q.hin)
            ?~   gyd
              =.  +>.$  (give %mean ~ %peer-fail ~)
              (give [%dumb ~])
            =+  kee=[you t.t.t.pax]
            =+  ash=(sham q.q.u.gyd)
            ?:  =(`ash (~(get by peq.sat) ost))
              +>.$
            =.  +>.$
              ?:  (~(has by sup.sat) ost)  +>.$  (give %nice ~)
            %-  %=  give
                  peq.sat  (~(put by peq.sat) ost ash)
                  sup.sat  (~(put by sup.sat) ost kee)
                  pus.sat  (~(put ju pus.sat) +.kee ost)
                ==
            (best %rust u.gyd)
          ::
              %peer
            ::  ~&  [%peer-goning onz=onz.sat]
            ?>  ?=([@ *] t.t.pax)
            =+  you=(need (slaw %p i.t.t.pax))
            =^  gud  +>.$  (mack q.hin)
            ?^  gud
              =.  +>.$  (give %mean ~ %peer-fail ~)
              (give [%dumb ~])
            =.  +>.$  (give %nice ~)
            %=  +>.$
              sup.sat  (~(put by sup.sat) ost [you t.t.t.pax])
              pus.sat  (~(put ju pus.sat) t.t.t.pax ost)
            ==
          ::
              %poke
            =^  gud  +>.$  (mack q.hin)
            ?^  gud  (give %mean ~ %poke-mack-fail u.gud)
            +>.$
          ::
              %pour
            =^  gud  +>.$  (mack q.hin)
            ?^  gud  ~&  -.gud  +>.$
            +>.$
          ::
              %prep
            =^  gad  +>.$  (mick q.hin)
            ?.  p.gad  (drum q.gad)
            deal:(drum q.gad)
          ::
              %pull
            =^  gud  +>.$  (mack q.hin)
            ?^  gud  +>.$
            blow
          ==
        ::
            %u                                          ::  user request
          %_    +>.$
              vey.sat
            (~(put to vey.sat) [hen [%take t.pax hin]])
          ==
        ::
            %w                                          ::  autoboot
          ?>  ?=([%drug @ @ ~] t.pax)
          =+  :*  sin=((hard ,[%c %writ p=riot]) q.hin)
                  our=(need (slaw %p i.t.t.pax))
                  syd=(need ((sand %tas) i.t.t.t.pax))
              ==
          ::~&  [%sync-notified `@p`our `@ta`syd]
          =.  ped.sat  (~(del by ped.sat) [our syd])
          ?~  p.+.sin
            +>.$
          +>.$(vey.sat (~(put to vey.sat) hen %boot ~))
        ==
      ::
      ++  morn                                          ::  install core
        |=  vax=vase
        ^+  +>
        =+  new=?~(huv.sat & !=(+<+.q.vax +<+.q.u.huv.sat))
        ::  ?.  ?=(%core -.p.vax)
        ::    ~|  [%morn-not-core -.p.vax app.sat imp]
        ::    ~>  %mean.|.((skol p.vax))
        ::    !!
        =.  huv.sat  `vax
        ?.  new  +>.$
        =:  act.sat  +(act.sat)
            lat.sat  now
          ==
        =+  pex=(~(tap by peq.sat) ~)
        |-  ^+  +>.^$
        ?~  pex  +>.^$
        %=  $
          pex    t.pex
          +>.^$  (quem(hen (able p.i.pex)) [%show (~(got by sup.sat) p.i.pex)])
        ==
      ::
      ++  mort                                          ::  failed boot
        |=  tan=(list tank)
        (give %crud %boot-lost tan)
      ::
      ++  nile  [%done ~ [%$ [%cube 0 [%atom %n]] ~]]   ::  null silk
      ++  obey                                          ::  process app moves
        |=  vax=vase
        =^  sax  mow  (said vax)
        +>.$(vey.sat (~(gas to vey.sat) sax))
      ::
      ++  quem                                          ::  queue action
        |=  kon=knob                                    ::  content
        ^+  +>
        =.  +>  ?.  ?=(%nuke -.kon)  +>
            ?.  &(?=(^ onz.sat) =(hen p.u.onz.sat))  +>
            ~&  [%nukeando imp=imp onz=onz.sat]
            %=    +>
                onz.sat  ~
                mow
              :_(mow [hen %pass (away q.u.onz.sat) %f [%exec our ~]])
            ==
        +>.$(vey.sat (~(put to vey.sat) hen kon))
      ::
      ++  quen                                          ::  push on front
        |=  kon=knob
        ^+  +>
        =+  yov=(~(tap by vey.sat) ~)                   ::  XX ++pun
        +>.$(vey.sat (~(gas to *(qeu toil)) `_yov`[[hen kon] yov]))
      ::
      ++  said                                          ::  sayz, done wrong
        |=  vud=vase
        =-  [p.fob (weld (flop q.fob) mow)]
        ^=  fob
        |-  ^-  (pair (list toil) (list move))
        ?:  =(~ q.vud)  [~ ~]
        =+  sud=(sump (slot 2 vud))
        =+  res=$(vud (slot 3 vud))
        :-  ?~  -.sud 
              -.res 
            [u.-.sud -.res]
        ?~  +.sud 
          +.res 
        [u.+.sud +.res]
      ::
      ++  sayz                                          ::  dissect app moves
        |=  vud=vase
        =|  toy=(list toil)
        |-  ^-  [(list toil) (list move)]
        ?:  =(~ q.vud)  [toy mow]
        =+  sud=(sump (slot 2 vud))
        %=    $
          vud  (slot 3 vud)
          toy  ?~(-.sud toy [u.-.sud toy])
          mow  ?~(+.sud mow [u.+.sud mow])
        ==
      ::
      ++  show                                          ::  subscribe
        |=  [you=ship pax=path]                         ::  subscription
        %_(+> vey.sat (~(put to vey.sat) hen %show you pax))
      ::
      ++  sumo                                          ::  standard gift
        |=  vig=vase
        ^-  gift
        [%meta vig]
      ::
      ++  sump
        |=  wec=vase
        ^-  [(unit toil) (unit move)]
        =+  ost=((hard bone) -.q.wec)
        =+  hon=(able ost)
        =+  caq=(spec (slot 3 wec))
        ?+    q.caq   ~&(%sump-bad !!)
        ::
            [%pass p=* q=@tas r=[p=@tas q=*]]
          =+  wir=(away %u ((hard path) p.q.caq))
          ?:  ?=(%cide p.r.q.caq)  [`(deff wir hon caq) ~]
          ?:  ?=(%sire p.r.q.caq)  [~ `(birf wir hon caq)]
          :^  ~  ~  hon
          :^  %pass  wir
            (need ((sand %tas) ((hard ,@) q.q.caq)))
          [%meta (spec (slot 15 caq))]
        ::
            [%give p=[p=@tas q=*]]
          ?:  ?=(%mean p.p.q.caq)
            :-  `[hon %nuke our]
            `[hon %give %mean (ares q.p.q.caq)]
          :-  ?.  ?|  ?=(?(%rush %rust) p.p.q.caq)
                      ?&  ?=(%meta p.p.q.caq)
                          ?=([* ?(%rush %rust) *] q.p.q.caq)
                  ==  ==
                ~
              `[hon %told our]
          :+  ~  hon
          :-  %give
          ?:  ?=(%nice p.p.q.caq)  [%nice ~]
          (sumo (spec (slot 3 caq)))
        ==
      ::
      ++  warm                                          ::  vase has arm
        |=  cog=@tas
        ^-  ?
        ?~(huv.sat | (slab cog p.u.huv.sat))
      ::
      ++  work                                          ::  eat queue
        |-  ^+  +
        ?:  |(?=(^ qic.sat) =(~ vey.sat))  +.$          ::  nothing to do
        =^  yev  vey.sat  [p q]:~(get to vey.sat)
        ?:  (~(has in nuc.sat) p.yev)  $
        work:(yawn:(bing p.yev) q.yev)
      ::
      ++  xeno
        |=  [pim=path kon=knob]
        =^  mew  ..$.go
          ((goad($.go +:abet) hen ~) our pim kon)
        =.  mat  (~(got by pol.all) our)
        =.  sat  (fall (~(get by bum.mat) imp) sat)
        +>.$(mow (weld (flop mew) mow))
      ::
      ++  yawl                                          ::  invoke core
        |=  [[arm=term pax=path] tac=tank vax=vase sam=vase]
        ^+  +>
        %+  ford  [%s arm pax]
        :+  %dude  tac
        [%call (harm arm (conf (core vax))) (cove %$ sam)]
      ::
      ++  yawn                                          ::  start event
        |=  kon=knob
        ^+  +>
        ::  ~&  [%gall-yawn ost imp -.kon]
        =.  qic.sat  `[hen kon]
        ?-    -.kon
            %boot
          =.  orm.sat  `now
          %+  ford  /s/park
          ::  :+  %dude  leaf/"booting"
          ^-  silk
          :-  home
          ?~  huv.sat  nile
          ?:  =(~ q.u.huv.sat)  nile
          :-  nile
          ?.  (warm %park)
            [%done ~ %$ (slot 13 u.huv.sat)]
          (harm %park (conf (core u.huv.sat)))
        ::
            %cede
          ?:  (warm %part)
            =+  sam=!>(ost)
            ?>  ?=(^ huv.sat)
            (yawl /part leaf/"parting" u.huv.sat sam)
          leav
        ::
            %cide
          ?~  p.kon
            ?~  imp    +>.$(qic.sat ~)
            ?~  t.imp
              $(kon [%cede ~])
            =.  qic.sat  ~
            (xeno t.imp %cide i.imp)
          ?.  (~(has by bum.mat) [p.kon imp])
            ~&  >  [%cide-missed p.kon imp]  +>.$(qic.sat ~)
          ::~&  [%cide-found p.kon imp]
          =.  +>.$  (xeno [p.kon imp] %cede ~)
          %_  +>.$
            cub.sat  (~(del by cub.sat) p.kon)
            qic.sat  ~
          ==
        ::
            %feel
          +>.$(qic.sat ~)
        ::
            %took
          =+  qol=(~(get by qel.sat) ost)
          ::  ~&  [%yawn-took-has ost qol [our hen]]
          %=    +>.$
              qic.sat  ~
              qel.sat  
            ?~  qol
              ::  ~&  [%took-underflow our hen]
              qel.sat
            ?:  =(`1 qol)
              (~(del by qel.sat) ost)
            (~(put by qel.sat) ost (dec u.qol))
          ==
        ::
            %told
          =+  qol=(~(get by qel.sat) ost)
          ::  ~&  [%yawn-told-has ost qol [our hen]]
          =+  qul=?~(qol 1 +(u.qol))
          =.  qel.sat  (~(put by qel.sat) ost qul)
          ?:  =(10 qul)
            ~&  [%yawn-told-full ost our hen]
            +>.$(qic.sat ~, vey.sat (~(put to vey.sat) hen %nuke p.kon))
          +>.$(qic.sat ~)
        ::
            %load
          =+  [hom=(slot 2 q.p.kon) old=(slot 3 q.p.kon)]
          %+  ford  /s/prep
          :+  %dude  leaf/"prepping"
          ?.  (warm(huv.sat `hom) %prep)
            :-  nile
            ?:  =(~ q.old)
              (core hom)
            :+  %mute  `silk`(core hom)
            :~  [[%$ 13]~ (cave (slot 3 old))]
            ==
          [%call (harm %prep (conf (core hom))) [nile (cave old)]]
        ::
            %crud
          (give(qic.sat ~) %crud p.kon q.kon)
        ::
            %nuke
          ?.  (warm %pull)
            blow
          ?>  ?=(^ huv.sat)
          (yawl [%pull ~] leaf/"pulling" u.huv.sat [[%atom %ud] ost])
        ::
            %mess
          =+  ^-  cog=term
              =-  |-  ?~  goz  ?:((warm %pock) %pock %poke)
                      ?:  (warm i.goz)  i.goz
                      $(goz t.goz)
              ^-  goz=(list term)
              ?:  =(%$ p.q.kon)
                /pock
              =+  ^=  goc
                  |=  [a=term b=(list term)]
                  [(cat 3 'pock-' a) (cat 3 'poke-' a) b]
              =+  ofs=(met 3 app.sat)
              ?.  .=  (cat 3 app.sat '-')   ::  XX temporary, until /=main=/bin
                  (end 3 +(ofs) p.q.kon)
                (goc p.q.kon /pock)
              :(goc p.q.kon (rsh 3 ofs p.q.kon) /pock)
          =+  hyp=?=(%pock (end 3 4 cog))
          =+  ^-  err=tape
              ?.(?=(?(%poke %pock) cog) <cog> "{<cog>} with mark {<p.q.kon>}")
          ?.  (warm cog)
            (give(qic.sat ~) %mean ~ %poke-find-fail leaf/err ~)
          ?>  ?=(^ huv.sat)
          =+  ^=  sam
              ;:  slop
                [[%atom %ud] ost] 
                [[%atom %p] p.kon] 
                ?.(hyp q.q.kon (slop !>(p.q.q.kon) q.q.kon))
              ==
          ::  ~&  [%mess-poke cog]
          %+  ford  /s/poke
          :+  %dude  leaf/err
          [%call (harm cog (conf (core u.huv.sat))) (cove %$ sam)]
        ::
            %show
          ::  ~&  showing/[app.sat imp q.kon]
          ?:  (warm %peer)
            =+  sam=!>([ost p.kon q.kon])
            ?>  ?=(^ huv.sat)
            =.  peq.sat  (~(del by peq.sat) ost)
            (yawl [%peer (scot %p p.kon) q.kon] leaf/"peering" u.huv.sat sam)
          ?:  (warm %peek)
            =+  sam=!>([p.kon q.kon])
            ?>  ?=(^ huv.sat)
            (yawl [%peek (scot %p p.kon) q.kon] leaf/"peeking" u.huv.sat sam)
          ~&  [%show-dumb app.sat imp q.kon]
          (give(qic.sat ~) %dumb ~)
        ::
            %sire
          ?:  (~(has by bum.mat) [q.kon imp])
            ~&  >  %sire-redundant  +>.$(qic.sat ~)
          ::~&  [%sire-made p.kon imp]
          =:    cub.sat  (~(put by cub.sat) q.kon p.kon)
                qic.sat  ~
                bum.mat
              %+  ~(put by bum.mat)  [q.kon imp]
              %*  .  *seat
                  app  p.kon
                  mom  `hen
                  zam
                ^-  scar
                :+  1
                  [[hun.mat 0 ~] ~ ~]
                [[0 hun.mat] ~ ~]
              ==
            ==
          (xeno [q.kon imp] %feel ~)
        ::
            %take
          ?:  ?&  ?=([%g %rush @ *] q.q.kon)
                  |((warm %posh) (warm (cat 3 'posh-' &3.q.q.kon)))
              ==
            ?>  ?=(^ huv.sat)
            =+  [goc gil]=[(cat 3 'posh-' &3.q.q.kon) (spec (slot 7 q.kon))]
            =.  -  ?:((warm goc) [goc (slot 3 gil)] [%posh gil])
            =+  sam=:(slop [[%atom %ud] ost] !>(p.kon) gil)
            %+  ford  /s/pour
            :+  %dude  leaf/"pouring"
            :+  %dude  (skol p.gil)
            [%call (harm goc (conf (core u.huv.sat))) (cove %$ sam)]
          ?:  (warm %purr)
            ?>  ?=(^ huv.sat)
            =+  sam=:(slop [[%atom %ud] ost] !>(p.kon) !>(p.q.kon) q.kon)
            %+  ford  /s/pour
            :+  %dude  leaf/"purring"
            [%call (harm %purr (conf (core u.huv.sat))) (cove %$ sam)]
          ?.  (warm %pour)
            +>.$(qic.sat ~)
          ?>  ?=(^ huv.sat)
          =+  sam=:(slop [[%atom %ud] ost] !>(p.kon) q.kon)
          %+  ford  /s/pour
          :+  %dude  leaf/"pouring"
          [%call (harm %pour (conf (core u.huv.sat))) (cove %$ sam)]
        ==
  --  --
--  --
