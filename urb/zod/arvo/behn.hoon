!:  ::  %behn, agent execution
!?  163
::::
|=  pit=vase
=>  =~
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    rest of arvo
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  hood                                                ::  assembly plan
  $:  zus=@ud                                           ::  zuse kelvin
      sur=(list hoot)                                   ::  structures
      lib=(list hoof)                                   ::  libraries
      fan=(list horn)                                   ::  resources
      src=(list hoop)                                   ::  program
  ==                                                    ::
++  hoof  (pair term (unit (pair case ship)))           ::  resource reference
++  hoot  (pair bean hoof)                              ::  structure gate/core
++  hoop                                                ::  source in hood
  $%  [%& p=twig]                                       ::  direct twig
      [%| p=beam]                                       ::  resource location   
  ==                                                    ::
++  horn                                                ::  resource tree
  $%  [%ape p=twig]                                     ::  /~  twig by hand
      [%arg p=twig]                                     ::  /$  argument
      [%day p=horn]                                     ::  /|  list by @dr
      [%dub p=term q=horn]                              ::  /=  apply face
      [%fan p=(list horn)]                              ::  /.  list
      [%for p=path q=horn]                              ::  /,  descend
      [%hel p=@ud q=horn]                               ::  /%  propagate heel
      [%hub p=horn]                                     ::  /@  list by @ud
      [%man p=(map span horn)]                          ::  /*  hetero map
      [%nap p=horn]                                     ::  /_  homo map
      [%now p=horn]                                     ::  /&  list by @da
      [%saw p=twig q=horn]                              ::  /;  operate on
      [%see p=beam q=horn]                              ::  /:  relative to
      [%sic p=tile q=horn]                              ::  /^  cast
      [%toy p=mark]                                     ::  /mark/  static
  ==                                                    ::
++  silk                                                ::  construction layer
  $&  [p=silk q=silk]                                   ::  cons
  $%  [%bake p=mark q=beam r=path]                      ::  local synthesis
      [%boil p=mark q=beam r=path]                      ::  general synthesis
      [%call p=silk q=silk]                             ::  slam
      [%cast p=mark q=silk]                             ::  translate
      [%done p=(set beam) q=cage]                       ::  literal
      [%dude p=tank q=silk]                             ::  error wrap
      [%dune p=(set beam) q=(unit cage)]                ::  unit literal
      [%mute p=silk q=(list (pair wing silk))]          ::  mutant
      [%plan p=beam q=spur r=hood]                      ::  structured build
      [%reef ~]                                         ::  kernel reef
      [%ride p=twig q=silk]                             ::  silk thru twig
      [%vale p=mark q=ship r=*]                         ::  validate [our his]
  ==                                                    ::
++  volt  ?(%low %high)                                 ::  voltage
++  torc  $|(?(%iron %gold) [%lead p=ship])             ::  security control
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    local arvo
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  club                                                ::  agent action
  $%  ::  [%kick ~]                                     ::  reboot
      ::  [%kill ~]                                     ::  reboot and delete
      [%peer p=path]                                    ::  subscribe
      ::  [%look p=path]                                ::  peer then pull 
      [%poke p=cage]                                    ::  apply
      [%pull p=path]                                    ::  unsubscribe
      [%swap p=ship q=desk]                             ::  hotswap
      [%took ~]                                         ::  acknowledge rush
      [%wipe ~]                                         ::  reinitialize
  ==                                                    ::
++  cusp                                                ::  action by agent
  $%  [%load p=scup]                                    ::  load / swap
  ::  [%stop ~]                                         ::  toggle suspend
      [%unto p=club]                                    ::  act in agent
  ==                                                    ::
++  cuss  (pair dude cusp)                              ::  internal kiss
++  cuft                                                ::  internal gift
  $%  [%coup p=(unit tang)]                             ::  poke result
      [%quit p=~]                                       ::  close subscription
      [%reap p=(unit tang)]                             ::  peer result
      [%rush p=cage]                                    ::  subscription output
  ==                                                    ::
++  cote                                                ::  ++ap note
      [%meta p=@tas q=vase]                             ::  
      [%send p=ship q=cuss]                             ::  
  ==                                                    ::
++  cove  (pair duct (mold cuft cote))                  ::  internal move 
++  dude  term                                          ::  local identity
++  tang  (list tank)                                   ::  error abstraction
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    %behn cards
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  kiss-behn                                           ::  incoming request
  $:  [%deal p=sock q=cuss]                             ::  full transmission
      [%init p=ship]                                    ::  set owner
  ==                                                    ::
++  gift-behn                                           ::  outgoing result
  $?  cuft
  $%  [%stat p=(unit tang)]                             ::  installer status
  ==                                                    ::
++  sign-behn                                           ::  incoming result
  $%  [%f gift-ford]                                    ::
      [%e gift-eyre]                                    ::
      [%d gift-dill]                                    ::
      [%c gift-clay]                                    ::
      [%a gift-ames]                                    ::
  ==                                                    ::
++  note-behn                                           ::  outgoing request
  !!                                                    ::
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    %behn state
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  axle                                                ::  all state
  $:  %0                                                ::  state version
      pol=(map ship mast)                               ::  apps by ship
  ==                                                    ::
++  gest                                                ::  subscriber data
  $:  sup=(map bone (pair ship path))                   ::  subscribers
      pus=(jug path bone)                               ::  srebircsbus
      qel=(map bone ,@ud)                               ::  queue meter
  ==                                                    ::
++  mast                                                ::  ship state
  $:  sys=duct                                          ::  system duct
      sap=(map ship scad)                               ::  foreign contacts
      bum=(map dude seat)                               ::  running agents
      wub=(map dude sofa)                               ::  waiting queue
  ==                                                    ::
++  ffuc                                                ::  new cuff
    $:  p=(unit (set ship))                             ::  disclosing to
        q=ship                                          ::  attributed to
    ==                                                  ::
++  prey  (pair volt ffuc)                              ::  privilege
++  scad                                                ::  opaque for foreign
  $:  p=@ud                                             ::  index
      q=(map duct ,@ud)                                 ::  by duct
      r=(map ,@ud duct)                                 ::  by index
  ==                                                    ::
++  scar                                                ::  opaque input
  $:  p=@ud                                             ::  bone sequence
      q=(map duct bone)                                 ::  by duct
      r=(map bone duct)                                 ::  by bone
  ==                                                    ::
++  scup  (pair ship desk)                              ::  autoupdate
++  seat                                                ::  agent state
  $:  mom=duct                                          ::  control duct 
      liv=?                                             ::  unstopped
      toc=torc                                          ::  privilege
      tyc=stic                                          ::  statistics
      ged=gest                                          ::  subscribers
      hav=vase                                          ::  running state
      pup=scup                                          ::  update control
      zam=scar                                          ::  opaque ducts
  ==                                                    ::
++  sofa  (qeu (pair duct kiss))                        ::  waiting kisses
++  stic                                                ::  statistics
  $:  act=@ud                                           ::  change number
      eny=@uvI                                          ::  entropy
      lat=@da                                           ::  time
  ==                                                    ::
--                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    vane header
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
=|  all=axle                                            ::  all vane state
|=  $:  $:  now=@da                                     ::  urban time
            eny=@uvI                                    ::  entropy
        ::  our=@p                                      ::  identity (future)
        ==                                              ::
        ska=sled                                        ::  activate
    ==                                                  ::  opaque core
=>                                                      ::
|%  ::::::::::::::::::::::::::::::::::::::::::::::::::::::    state machine
    ::::::::::::::::::::::::::::::::::::::::::::::::::::::
++  mo
  |_  $:  $:  our=@p 
              hen=duct
              moz=(list move)
          ==
          mast
      ==
  ++  mo-abed                                           ::  initialize
    |=  [our=@p hen=duct]
    ^+  +>
    %_    +>
      ^our  our
      ^hen  hen
      +<+   (~(got by pol.all) our)
    ==
  ::
  ++  mo-abet                                           ::  resolve to 
    ^-  [(list move) +>]
    :_  +>(pol.all (~(put by pol.all) +<+))
    %-  flop
    %+  turn  moz
    |=  a=move
    ?.  ?=(%pass -.a)  a
    [%pass [(scot %p our) p.a] q.a]
  ::
  ++  mo-pass                                           ::  standard pass
    |=  [pax=path noh=note]
    %_(+> moz :_(moz [hen %pass pax noh]))
  ::
  ++  mo-boom                                           ::  complete new boot
    |=  [dap=dude pup=scup dep=@uvH cux=(each cage tang)]
    ^+  +>
    ?-    -.cux
        %|  (mo-give %stat `p.cux)
        %&
      =.  +>  (mo-give %stat ~)
      =.  +>  (mo-bold dap pup dep)
      ap-abet:(ap-prep:(ap-abbe dap [%high [~ our]] pup q.u.cux)
    ==
  ::
  ++  mo-boon                                           ::  complete old boot
    |=  [dap=dude pup=scup dep=@uvH cux=(each cage tang)]
    ^+  +>
    ?.  (~(has by bum) dap)  
      ~&  [%behn-old-boon dap]
      +>
    =.  +>  (mo-bold dap pup dep)
    ?-  -.cux
      %|  (mo-give %stat `p.cux)
      %&ap-abet:(ap-prep:(ap-abed:ap dap [%high [~ our]]) pup `p.cux)
  ::
  ++  mo-bold                                           ::  wait for dep
    |=  [dap=dude pup=scup dep=@uvH]
    ^+  +>
    %+  mo-pass  [%sys %old dap (scot %p p.pup) q.pup ~] 
    [%f %wasp our dep]
  ::
  ++  mo-boot                                           ::  create ship
    |=  [dap=dude how=?(%new %old) pup=scup]
    ^+  +>
    %+  mo-pass  [%sys how dap (scot %p p.pup) q.pup ~]
    [%f %exec our %boil %gate [who syd (scot %da now)] [dap %ape ~] ~]
  ::
  ++  mo-away                                           ::  foreign request
    |=  [him=ship caz=cuss]                             ::  
    %+  mo-pass  [%sys %way ~] 
    [%wont [our him] [p.caz ~] q.caz]
  ::
  ++  mo-come
    |=  [her=ship caz=cuss]
    =+  pry=`prey`[%high [~ her]]
    ?-    -.caz
        %load  
      ?:  (~(has in bum) p.caz)
        (mo-club p.caz pry [%swap q.caz])
      (mo-boot p.caz q.caz)
    ::
        %unto
      (mo-club p.caz pry q.caz)
    ==
  ::
  ++  mo-cyst                                           ::  take in /sys
    |=  [pax=path sih=sign]
    ?-    -.pax
        %old  
      ?>  ?=([%f %made *] sih)
      ?>  ?=([@ @ @ ~] pax)
      (mo-boon i.t.pax [(slav %p i.pax) i.t.t.pax] +>.sih)
    ::
        %new
      ?>  ?=([%f %made *] sih)
      ?>  ?=([@ @ @ ~] pax)
      (mo-boom i.t.pax [(slav %p i.pax) i.t.t.pax] +>.sih)
    ::
        %way
      ?>  ?=([%a %woot *] sih)
      !!
    ==
  ::
  ++  mo-cook                                           ::  take in /use
    |=  [pax=path hin=(hypo sign)]
    ?>  ?=([@ @ ?(%inn %out) *] pax)
    =+  dap=`@tas`i.pax
    =+  pry=`prey`[%high [~ (slav %p i.t.pax)]]
    =+  pap=(ap-abed:ap i.t.pax pry) 
    =<  ap-abet
    ?-  i.t.t.pax
      %inn  (ap-pour:pap t.t.t.pax `vase`hin)
      %out  (ap-pout:pap t.t.t.pax `vase`hin)
    ==
  ::
  ++  mo-club                                           ::  local action
    |=  [dap=dude pry=prey cub=club]
    ap-abet:(ap-club:(ap-abed:ap dap pry) cub)
  ::
  ++  mo-gawk                                           ::  ames response
    |=  [saq=sack imp=path num=@ud ron=roon]
    !!
  ::
  ++  mo-gawd                                           ::  ames request
    |=  [saq=sack imp=path num=@ud rok=rook]
    !!
  ::
  ++  ap
    |_  $:  $:  dap=dude
                pry=prey
                ost=bone
                zip=(list cove)
            ==
            seat
        ==
    ++  ap-abbe                                         ::  create
      |=  [dap=dude pry=prey pup=scup hav=vase]
      =.  +>  (ap-abed dap pry)
      %_  +>
        mom    hen
        pup    pup
        hav    hav 
        p.zam  1
        q.zam  (~(put by q.zam) ~ 0)
        r.zam  (~(put by r.zam) 0 ~)
      ==
    ::
    ++  ap-abed                                         ::  initialize
      |=  [dap=dude pry=prey]
      ^+  +>
      =:  ^dap  dap
          ^pry  pry
        ==
      =+  unt=(~(get by q.zam) hen)
      ?^  unt
        +>.$(ost p.u.unt, sec q.u.unt)
      %=  +>.$
        ost  p.zam
        p.zam  +(p.zam)
        q.zam  (~(put by q.zam) hen p.zam)
        r.zam  (~(put by r.zam) p.zam hen)
      ==
    ::
    ++  ap-abet                                         ::  resolve
      ^+  +>
      %_  +>  
        bum  (~(put by bum) dap +<+)
        moz  (weld (turn zip ap-aver) moz)
      ==
    ::
    ++  ap-aver                                         ::  cove to move
      |=  cov=cove
      ^-  move 
      :-  p.cov
      ?:    -.q.cov
          %give  q.cov
          %pass
        :-  [%use dap p.q.cov]
        ?-  -.q.q.cov
          %send  [%g %deal [our p.q.q.cov] q.q.q.cov]
          %meta  [p.q.q.cov %meta q.q.cov]
        ==
      ==
    ::
    ++  ap-club                                         ::  apply effect
      |=  cub=club
      ^+  +>
      ?+  -.cub  !!
        %poke   (ap-poke +.cub)
        %peer   (ap-peer +.cub)
        %took   ap-fall
      ==
    ::
    ++  ap-find                                         ::  general arm
      |=  [cog=term pax=path]
      =+  dep=0
      |-  ^-  (unit (pair ,@ud term))
      =+  ^=  spu
          ?~  pax  ~ 
          $(pax t.pax, dep +(dep), cog (ap-hype cog i.pax))
      ?^  spu  spu
      ?:((ap-fond cog) ~ `[dep cog])
    ::
    ++  ap-fall                                         ::  drop from queue
      ^-  .
      =+  soy=(~(get by qel.ged) ost)
      ?~  soy  ~&(%ap-fall-underflow +)
      ?:  =(0 soy)  
        +(qel.ged (~(del by qel.ged) ost))
      +(qel.ged (~(put by qel.ged) ost (dec soy)))
    ::
    ++  ap-fill                                         ::  add to queue
      ^-  [? _.]
      =+  suy=(fall (~(get by qel.ged) ost) 0)
      ?:  =(10 suy)  [%| +]
      [%& +>(qel.ged (~(put by qel.ged) ost +(suy)))]
    ::
    ++  ap-fond                                         ::  check for arm
      |=  cog=term
      ^-  ?
      (slab cog p.hav)
    ::
    ++  ap-hype                                         ::  hyphenate
      |=([a=term b=term] `term`(cat 3 a (cat 3 '-' b))
    ::
    ++  ap-give                                         ::  return result
      |=  cit=cuft
      ^+  +>
      +>(zip :_(zip [(~(got by r.zam) ost) %give cit]))
    ::
    ++  ap-pass                                         ::  request action
      |=  [pax=path coh=cote]
      ^+  +>
      +>(zip :_(zip [(~(got by r.zam) ost) %pass pax coh]))
    ::
    ++  ap-call                                         ::  call into vase
      |=  [cog=term vax=vase]
      ^-  [(unit tang) _+>]
      =+  puz=(mule |.((~(mint ut p.vax) [%noun [%cnzy cog]])))
      =-  ?-  -.zep
            %|  [`+.zep +>.$]
            %&  (ap-sake +.zep)
          ==
      ^=  zep 
      ?-    -.puz
          %|  [%| +.puz]
          %&
        =+  ton=(mock [q.vax q.p.puz] |=(* ~))
        ?-  -.ton
          %0  [%& p.ton]
          %1  [%| (turn p.ton |=(a=* (smyt (path a))))]
          %2  [%| p.ton]
        ==
      ==
    ::
    ++  ap-suck                                         ::  standard tang
      |=  msg=tape
      ^-  tang
      [%leaf (weld "behn: {<dap>}:" msg)]~
    ::
    ++  ap-safe                                         ::  process move list
      |=  vax=vase
      ^-  (each (list move) tang)
      ?~  q.vax  [%& ~]
      =+  sud=(ap-move (slot 2 vax))
      ?:  ?=(%| -.sud)  sud
      =+  res=$(vax (slot 3 vax))
      ?:  ?=(%| -.res)  res
      [%& p.sud p.res]
    ::
    ++  ap-move                                         ::  process each move
      |=  vax=vase
      ^-  (each move tang)
      ?@  q.vax    [%| (ap-suck "move: invalid move (atom)")]
      ?^  -.q.vax  [%| (ap-suck "move: invalid move (bone)")]
      ?@  +.q.vax  [%| (ap-suck "move: invalid move (card)")]
      =+  hun=(~(get by r.zam) -.q.vax)
      ?~  hun  [%| (ap-suck "move: invalid card (bone)")]
      =+  cav=(slot 7 q.vax)
      ?+  +<.q.vax
        %rush  (ap-move-rush u.hun cav)
        %send  (ap-move-send u.hun cav)
        %pass  (ap-move-pass u.hun cav)
        %quit  (ap-move-quit u.hun cav)
      ==
    ::
    ++  ap-move-quit                                    ::  give quit move
      |=  [neh=duct vax=vase]
      ^-  (each move tang)
      ?^  q.vax  [%| (ap-suck "move: improper quit")]
      [%& neh %give %quit ~]
    ::
    ++  ap-term                                         ::  atomic vase
      |=  [a=@tas b=@]  
      ^-  vase
      [[%cube b %atom a] a]
    ::
    ++  ap-move-rush                                    ::  give rush move
      |=  [neh=duct vax=vase]
      ^-  (each cove tang)
      ?.  &(?=(^ q.vax) ?=(@ -.q.vax) ((sane %tas) -.q.vax))
        [%| (ap-suck "move: improper rush")]
      [%& neh %rush `cage`[-.q.vax vax]]
    ::
    ++  ap-move-send                                    ::  pass gall action
      |=  [neh=duct vax=vase]
      ^-  (each cove tang)
          ::        2 3  6 7 14 15 30  31
      ?.  ?&  ?=([p=* [q=@ [r=@ [s=@ t=*] q.vax)
              (gte 1 (met 7 q.q.vax))
              ((sane %tas) r.q.vax)
          ==
        [%| (ap-suck "move: malformed send")]
      =+  pux=((soft path) p.q.vax)
      ?.  &(?=(^ pux) (levy u.pux (sane %ta)))
        [%| (ap-suck "move: malformed path"]
      ?:  ?=(%poke s.q.vax)
        ?.  ?&  ?=([p=@ q=*] t.q.vax)
                ((sane %tas) p.t.q.vax)
            ==
          [%| (ap-suck "move: malformed poke")]
        :^  %&  neh  %pass
        :-  [(scot %p q.q.vax) %out r.q.vax u.pux]
        [%send q.q.vax r.q.vax %poke p.t.q.vax (slot 31 vax)]
      =+  cob=((soft club) [s t]:q.vax)
      ?~  cob
        [%| (ap-suck "move: malformed club")]
      :^  %&  neh  %pass
      :-  [(scot %p q.q.vax) %out r.q.vax u.pux]
      [%send q.q.vax r.q.vax u.cob]
    ::
    ++  ap-vain                                         ::  card to vane
      |=  sep=@tas
      ^-  (unit ,@tas)
      ?+  sep  ~&  [%ap-vain sep]
               ~
        %exec  `%f
        ::  etc
      ==
    ::
    ++  ap-move-pass                                    ::  pass general move 
      |=  [neh=duct vax=vase]
      ^-  (each cove tang)
      ?.  &(?=([* @ *] q.vax) ((sane %tas) -.q.vax))
        [%| (ap-suck "move: malformed pass"]
      =+  pux=((soft path) -.q.vax)
      ?.  &(?=(^ pux) (levy u.pux (sane %ta)))
        [%| (ap-suck "move: malformed path"]
      =+  huj=(ap-easy +<.q.vax)
      ?~  huj
        [%| (ap-suck "move: unknown note {(trip +<.q.vax)}")]
      :^  %&  neh  %pass 
      :-  [(scot %p q.q.pry) %inn u.pux]
      [%meta u.huj (slot 7 vax)]
    ::
    ++  ap-save                                         ::  verify core
      |=  vax=vase
      ^-  (each vase tang)
      [%& vax]
    ::
    ++  ap-sake                                         ::  handle result
      |=  vax=vase
      ^-  [(unit tang) _+>]
      ?:  ?=(@ q.vax)
        [`(ap-suck "sake: invalid product (atom)") +>.$]
      =+  muz=(ap-safe (slot 2 vax))
      ?:  ?=(%| -.muz)  [`p.muz +>]
      =+  sav=(ap-save (slot 3 vax))
      ?:  ?=(%| -.sav)  [`p.sav +>]
      :-  ~
      %_  +>.$
        zip  (weld (flop p.muz) zip)
        hav  p.sav 
      ==
    ::
    ++  ap-poke                                         ::  apply %poke
      |=  cag=cage
      ^+  +>
      =+  cug=(ap-find %poke p.cag ~)
      %+  ap-give  %coup
      ?~  cug
        `(ap-suck "no poke arm"))
      %+  ap-call  q.u.cug
      ;:  slop
        !>(`@p`q.q.pry)
        !>(`@ud`ost)
        ?.  =(0 p.u.cug)  q.cag
        (slop (ap-term p.cag) q.cag)
      ==
    ::
    ++  ap-peon                                         ::  add subscriber
      |=  pax=path
      %_  +>.$
        sup.sat  (~(put by sup.sat) ost [you pax])
        pus.sat  (~(put ju pus.sat) pax ost)
      ==
    ::
    ++  ap-peer                                         ::  apply %peer
      |=  pax=path
      ^+  +>
      =+  cug=(ap-find %peer pax)
      ?~  cug
        (ap-peon pax)
      =^  cam  +>.$ 
          %+  ap-call  q.u.cug
          !>([`@ud`ost `@p`q.q.pry `path`(slag p.u.cug pax)])
      ?^  cam
        (ap-give %reap cam)
      (ap-give:(ap-peon pax) %reap ~)
    ::
    ++  ap-pour-fail                                    ::  pour error
      |=  why=tang
      ^+  +>
      ~&  [%punt why]
      ~|  why
      !!      ::  XX not right but...
    ::
    ++  ap-pour                                         ::  generic take
      |=  [pax=path vax=vase]
      ^+  +>
      ?.  &(?=([@ *] q.vax) ((sane %tas) -.q.vax))
        (ap-pour-fail (ap-suck "pour: malformed card"))
      =+  cug=(ap-find [%pour -.q.vax pax])
      ?~  cug
        (ap-pour-fail (ap-suck "pour: nothing for {(trip -.q.vax)}: {<pax>}"))
      =^  cam  +>.$
          ;:  slop
            !>(`@p`q.q.pry)
            !>(`@ud`ost)
            ?.  =(0 p.u.cug)
              (slop !>(`path`pax) vax)
            (slop !>(`path`(slag p.u.cug)) (slot 3 vax))
          ==
      ?^  cam
        (ap-pour-fail u.cam)
      +>.$
    ::
    ++  ap-pout                                         ::  specific take
      |=  [pax=path vax=vase]
      ^+
      ?>  &(?=([@ *] pax) ((sane %tas) i.pax))
      =+  ape=i.pax 
      ?:  ?=(%rush -.q.vax)
        ?>  &(?=([@ *] +.q.vax) ((sane %tas) +<.q.vax))
        (ap-rush q.q.pry ape t.pax [+<.q.vax (slot 7 vax)])
      (ap-punk q.q.pry ape t.pax (slot 3 vax))
    ::
    ++  ap-punk                                         ::  non-rush gall take
      |=  [her=ship ape=term pax=path wut=term vax=vase]
      =+  cug=(ap-find [wut 
      !!
    ::
    ++  ap-rush-fail                                    ::  rush failed
      |=  [her=ship ape=term pax=path why=tang]
      ^+  +>
      ~&  [%ap-rush-fail her ape pax]
      ~&  [%ap-rush-tang why]
      !!  ::  XX not right but...
    ::
    ++  ap-rush                                         ::  pour a rush
      |=  [her=ship ape=term pax=path cag=cage]
      =+  cug=(ap-find [%rush p.cag pax])
      !!
    --
  --
++  call                                                ::  request
  |=  [hen=duct hic=(hypo (hobo kiss))]
  ^-  [p=(list move) q=_..^$]
  =>  .(q.hic ?.(?=(%soft -.q.hic) q.hic ((hard kiss) p.q.hic)))
  ?-    -.q.hic
      %deal
    ?~  ore.all 
      ~&  [%behn-from-cold `@tas`-.q.hic]
      [~ ..^$]
    =<  mo-abet
    ?.  (~(has in pol.all) q.p.q.hic)                   ::  either to us
      ?>  (~(has in pol.all) p.p.q.hic)                 ::  or from us
      (mo-away:(mo-abed:mo p.p.q.hic hen) q.p.q.hic q.q.hic)
    (mo-come:(mo-abed:mo q.p.q.hic hen) p.p.q.hic q.q.hic)
  ::
      %init 
    [~ .(ore.all `p.q.hic, pol.all (~(put by pol.all p.q.hic *mast)))]
  ::
      %rote
    !!
    :: mo-abet:(mo-gawk:mo-abed:mo p.q.hic q.q.hic ((hard ,[@ud rook]) r.q.hic))
  ::
      %roth
    !!
    ::  mo-abet:(mo-gawd p.q.hic q.q.hic ((hard ,[@ud roon]) r.q.hic))
  ==
::
++  doze                                                ::  sleep until
  |=  [now=@da hen=duct]
  ^-  (unit ,@da)
  ~
::
++  load                                                ::  highly forgiving
  |=  old=*
  =+  lox=((soft axle) old)
  ^+  ..^$
  ?~  lox
    ~&  %gall-reset
    ..^$
  ..^$(+>- u.lox)
::
++  scry
  |=  [fur=(unit (set monk)) ren=@tas who=ship syd=desk lot=coin tyl=path]
  ^-  (unit (unit (pair mark ,*)))
  [~ ~]
::
++  stay                                                ::  save w/o cache
  `axle`all
::
++  take                                                ::  response
  |=  [tea=wire hen=duct hin=(hypo sign)]
  ^-  [p=(list move) q=_..^$]
  ~|  [%behn-take tea]
  ?>  ?=([@ ?(%sys %use) *] tea) 
  =+  our=(need (slaw %p i.tea))
  =+  mow=(mo-abed:mo our hen)
  ?:  ?=(%sys i.t.tea)
    (mo-cyst:mow t.tea q.hin)
  (mo-cook:mow t.tea hin)
--
